{"name":"Lacquer","body":"= lacquer\r\n\r\nRails drop in for Varnish support.\r\n\r\n== Install\r\nThis gem requires ruby 1.9\r\n\r\nBasic installation\r\n\r\n  sudo gem install lacquer  \r\n  rails generate lacquer:install\r\n\r\nconfig/initializers/lacquer.rb\r\n\r\n  Lacquer.configure do |config|\r\n    # Globally enable/disable cache\r\n    config.enable_cache = true\r\n\r\n    # Unless overridden in a controller or action, the default will be used\r\n    config.default_ttl = 1.week\r\n\r\n    # Can be :none, :delayed_job, :resque\r\n    config.job_backend = :none\r\n\r\n    # Array of Varnish servers to manage\r\n    config.varnish_servers << {\r\n      :host => \"0.0.0.0\", :port => 6082 # if you have authentication enabled, add :secret => \"your secret\"\r\n    }\r\n\r\n    # Number of retries\r\n    config.retries = 5\r\n\r\n    # config handler (optional, if you use Hoptoad or another error tracking service)\r\n    config.command_error_handler = lambda { |s| HoptoadNotifier.notify(s) }\r\n    \r\n    \r\n    ### Varnish - 2.x  /  3.x  .. VCL-Changes\r\n    ### https://www.varnish-cache.org/docs/trunk/installation/upgrade.html\r\n    \r\n    # => Purge Command  ( \"url.purge\" for Varnish 2.x .. \"ban.url\" for Varnish 3.x )\r\n    # => purges are now called bans in Varnish 3.x .. purge() and purge_url() are now respectively ban() and ban_url()\r\n    config.purge_command = \"ban.url\"\r\n    \r\n    # => VCL_Fetch Pass Command  ( \"pass\" for Varnish 2.x .. \"hit_for_pass\" for Varnish 3.x )\r\n    # => pass in vcl_fetch renamed to hit_for_pass in Varnish 3.x   \r\n    config.pass_command = \"pass\"\r\n  end\r\n\r\napp/controllers/application_controller.rb\r\n\r\n  class ApplicationController < ActionController::Base\r\n    include Lacquer::CacheUtils\r\n  end\r\n  \r\nconfig/varnishd.yml\r\n\r\n  development:\r\n    listen: localhost:3001\r\n    telnet: localhost:6082\r\n    sbin_path: /usr/local/sbin\r\n    storage: \"file,#{Rails.root}/log/varnishd.#{Rails.env}.cache,100MB\"\r\n    \r\n  test:\r\n    listen: localhost:3002\r\n    telnet: localhost:6083\r\n    sbin_path: /usr/local/sbin\r\n    storage: \"file,#{Rails.root}/log/varnishd.#{Rails.env}.cache,100MB\"\r\n\r\n  production:\r\n    listen: :80\r\n    telnet: localhost:6082\r\n    sbin_path: /usr/local/sbin\r\n    storage: \"file,#{Rails.root}/log/varnishd.#{Rails.env}.cache,100MB\"\r\n    params:\r\n      overflow_max: 2000          # for Varnish 2.x ... use \"queue_max: 2000\" for Varnish 3.x\r\n      thread_pool_add_delay: 2\r\n      thread_pools: 4             # <Number of cpu cores>\r\n      thread_pool_min: 200        # <800/number of cpu cores>\r\n      thread_pool_max: 4000\r\n\r\nIf only some urls of the application should be cached by varnish, Lacquer::CacheControl will be helpful.\r\n\r\nconfig/initializers/caches.rb\r\n\r\n  require \"lacquer/cache_control\"\r\n\r\n  Lacquer.cache_control.configure do |config|\r\n    config.register :static,              :url => \"^/images\",                                           \r\n                                          :expires_in => \"365d\"\r\n                                        \r\n    config.register :static,              :url => \"^/stylesheets\",\r\n                                          :expires_in => \"365d\"\r\n                                        \r\n    config.register :static,              :url => \"^/javascripts\",                                       \r\n                                          :expires_in => \"365d\"\r\n  \r\n    config.register :class_section,       :url => \"^(/[a-z]{2})?/(info_screens|class_sections)/%s.*$\",   \r\n                                          :args => \"[0-9]+\", \r\n                                          :expires_in => \"1m\"\r\n                                        \r\n    config.register :open_scoring,        :url => \"^(/[a-z]{2})?/class_sections/%s/open_scoring.*$\",\r\n                                          :args => \"[0-9]+\",\r\n                                          :expires_in => \"1m\"\r\n                                        \r\n  end\r\n\r\nIn the sweeper we can do something like this\r\n\r\n  class_section = ClassSection.find(1)\r\n  Lacquer.cache_control.purge(:open_scoring, class_section) \r\n  \r\nThis will purge \"^(/[a-z]{2})?/class_sections/1/open_scoring.*$\" (/sv/class_sections/1/open_scoring.js, /sv/class_sections/1/open_scoring.html)\r\n  \r\nThe varnish.vcl is preprocssed when starting varnishd with the rake tasks\r\n\r\n  rake lacquer:varnishd:start\r\n  \r\nconfig/varnish.vcl.erb\r\n\r\n  sub vcl_recv {\r\n    # Lookup requests that we know should be cached\r\n    if (<%= Lacquer.cache_control.to_vcl_conditions %>) {    \r\n      # Clear cookie and authorization headers, set grace time, lookup in the cache\r\n      unset req.http.Cookie;\r\n      unset req.http.Authorization;\r\n      return(lookup);\r\n    }\r\n    \r\n    # Generates\r\n    #\r\n    # if(req.url ~ \"^/images\" || \r\n    #    req.url ~ \"^/stylesheets\" || \r\n    #    req.url ~ \"^/javascripts\" || \r\n    #    req.url ~ \"^(/[a-z]{2})?/(info_screens|class_sections)/[0-9]+.*$\" || \r\n    #    req.url ~ \"^(/[a-z]{2})?/class_sections/[0-9]+/open_scoring.*$\") {\r\n    #    unset req.http.Cookie;\r\n    #    unset req.http.Authorization;\r\n    #    return(lookup);         \r\n    # }\r\n  }\r\n\r\n  sub vcl_fetch {\r\n    <%= Lacquer.cache_control.to_vcl_override_ttl_urls %>\r\n    \r\n    # Generates\r\n    #\r\n    # if(req.url ~ \"^/images\" || req.url ~ \"^/stylesheets\" || req.url ~ \"^/javascripts\") {\r\n    #   unset beresp.http.Set-Cookie;\r\n    #   set beresp.ttl = 365d;\r\n    #   return(deliver);\r\n    # }\r\n    #\r\n    # if(req.url ~ \"^(/[a-z]{2})?/(info_screens|class_sections)/[0-9]+.*$\" || \r\n    #   req.url ~ \"^(/[a-z]{2})?/class_sections/[0-9]+/open_scoring.*$\") {\r\n    #   unset beresp.http.Set-Cookie;\r\n    #   set beresp.ttl = 1m;\r\n    #   return(deliver);\r\n    # }\r\n  }\r\n \r\nThis makes it much simpler to perform cacheing, it's only setuped in one place, purge it or just let it expire.\r\n  \r\n== Usage\r\n\r\nTo set a custom ttl for a controller:\r\n\r\n  before_filter { |controller| controller.set_cache_ttl(15.minutes) }\r\n\r\nClearing the cache:\r\n\r\n  class Posts < ApplicationController\r\n    after_filter :clear_cache, :only => [ :create, :update, :destroy ]\r\n\r\n  private\r\n\r\n    def clear_cache\r\n      clear_cache_for(\r\n        root_path,\r\n        posts_path,\r\n        post_path(@post))\r\n    end\r\n  end\r\n  \r\nControl varnishd with the following rake tasks\r\n\r\n  rake lacquer:varnishd:start\r\n  rake lacquer:varnishd:stop\r\n  rake lacquer:varnishd:restart\r\n  rake lacquer:varnishd:status\r\n  rake lacquer:varnishd:global_purge  \r\n\r\n== Gotchas\r\n\r\nThe default TTL for most actions is set to 0, since for most cases you'll probably want to be fairly explicit about what pages do get cached by varnish. The default cache header is typically:\r\n\r\n  Cache-Control: max-age=0, no-cache, private\r\n\r\nThis is good for normal controller actions, since you won't want to cache them. If TTL for an action is set to 0, it won't mess with the default header.\r\n\r\nThe key gotcha here is that cached pages strip cookies, so if your application relies on sessions and uses authenticity tokens, the user will need a session cookie set before form actions will work. Setting default TTL to 0 here will make sure these session cookies won't break.\r\n\r\nAs a result, all you have to do to set a cacheable action is the before filter above.\r\n\r\n== Note on Patches/Pull Requests\r\n\r\n* Fork the project.\r\n* Make your feature addition or bug fix.\r\n* Add tests for it. This is important so I don't break it in a future version unintentionally.\r\n* Commit, do not mess with rakefile, version, or history.  (if you want to have your own version, that is fine but bump version in a commit by itself I can ignore when I pull)\r\n* Send me a pull request. Bonus points for topic branches.\r\n\r\n== Copyright\r\n\r\nCopyright (c) 2010 Russ Smith. See LICENSE for details.","tagline":"Rails drop in for Varnish support.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}